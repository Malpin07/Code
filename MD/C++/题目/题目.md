<!-- TOC -->
* [C++语言中结构体和C语言中结构体不同的地方有哪些？](#c语言中结构体和c语言中结构体不同的地方有哪些)
* [c++类和结构体的区别](#c类和结构体的区别)
* [什么是函数重载？](#什么是函数重载)
* [内联函数和宏函数的区别？](#内联函数和宏函数的区别)
* [指针和引用的区别](#指针和引用的区别)
* [malloc/free和new/delete区别](#mallocfree和newdelete区别)
* [浅拷贝与深拷贝的区别](#浅拷贝与深拷贝的区别)
* [虚继承和虚函数](#虚继承和虚函数)
<!-- TOC -->

# C++语言中结构体和C语言中结构体不同的地方有哪些？
```c++
C++中的结构体（struct）与C语言中的结构体在很多方面是相似的，但也有一些重要的区别。
        
       
        
1. 成员函数
C语言：结构体只能包含数据成员（变量），不能包含函数。
C++：结构体可以包含成员函数，就像类一样。这使得结构体可以拥有自己的行为。

2. 默认访问权限
C语言：结构体的成员默认是公有的（public）。
C++：结构体的成员默认也是公有的（public），但与类不同，类的成员默认是私有的（private）。

3. 继承
C语言：不支持继承。
C++：支持继承，结构体可以继承自另一个结构体或类。

4. 构造函数和析构函数
C语言：不支持构造函数和析构函数。
C++：支持构造函数和析构函数，可以在结构体中定义。

5. 友元函数和友元类
C语言：不支持友元函数和友元类。
C++：支持友元函数和友元类，可以在结构体中声明。

6. 模板
C语言：不支持模板。
C++：支持模板，可以定义模板结构体。

7. 操作符重载
C语言：不支持操作符重载。
C++：支持操作符重载，可以在结构体中重载操作符。

```

# c++类和结构体的区别
```c++
类（class）的默认访问权限是私有的（private）。
结构体（struct）的默认访问权限是公有的（public）。
        
类（class）在继承时，默认的继承方式是私有的（private）。
结构体（struct）在继承时，默认的继承方式是公有的（public）。
        
类（class）通常用于定义需要封装和隐藏实现细节的对象。
结构体（struct）通常用于定义简单的数据集合，不需要复杂的封装和继承。        

```

# 什么是函数重载？
```c++
函数重载（Function Overloading）是C++中的一种特性，允许在同一个作用域内定义多个具有相同名称但参数列表不同的函数。
通过函数重载，可以根据不同的参数类型或参数数量来调用不同的函数实现，从而提高代码的复用性和可读性。

函数重载的规则
函数名称相同：重载的函数必须具有相同的名称。
参数列表不同：重载的函数必须在  参数数量  、参数类型   或  参数顺序   上有所不同。
返回类型无关 不能仅通过返回类型重载：函数的返回类型不是重载的依据，只有参数列表的不同才是重载的依据。
```

# 内联函数和宏函数的区别？

```c++
内联函数（Inline Function）和宏函数（Macro Function）都是在C++中用于提高程序执行效率的工具，
但它们在实现方式、类型安全、作用域和调试等方面存在显著差异


1. 实现方式
内联函数：内联函数是通过在函数定义前加上inline关键字来实现的。
建议 编译器在编译时会将内联函数的代码直接插入到调用该函数的地方，从而减少函数调用的开销。
宏函数：宏函数是通过预处理器指令#define定义的。预处理器在编译之前会将宏展开为相应的代码。

2. 类型安全
内联函数：类型安全，编译器进行类型检查。
宏函数：非类型安全，无类型检查。

3. 作用域
内联函数：有作用域，可在类或命名空间中定义。
宏函数：无作用域，全局有效。

4. 调试
内联函数：可调试，生成实际函数调用。
宏函数：难以调试，预处理阶段文本替换。

5. 代码膨胀
内联函数：可能导致代码膨胀，每个调用点插入函数体。
宏函数：同样导致代码膨胀，简单文本替换。

6. 语法和语义
内联函数：遵循C++语法和语义，支持重载、模板等。
宏函数：简单文本替换，不遵循C++语法和语义。

```
# 指针和引用的区别
```c++

指针更灵活，可以指向nullptr，可以修改指向,可以指向nullptr

引用更安全，必须在定义时初始化,且与原类型保持一致，且不分配内存。声明关系，一经声明，不可变更。
可对引用，再次引用。多次引用的结果，是某一变量具有多个别名，多个别名间是平行关系。

可以定义指针的指针(二级指针)
不能定义引用的引用(二级引用：没有这种说法)

```
# malloc/free和new/delete区别
```c++
语言关联：

malloc 和 free 是C语言中的标准库函数。
new 和 delete 是C++中的操作符。

类型安全：

malloc 返回的是 void* 类型，需要显式类型转换。
new 返回的是确切类型的指针，不需要类型转换，因此更类型安全。

构造和析构：

malloc 只分配内存，不调用构造函数。
new 不仅分配内存，还会调用对象的构造函数。
free 只释放内存，不调用析构函数。
delete 不仅释放内存，还会调用对象的析构函数。

错误处理：

malloc 在内存分配失败时返回 NULL。
new 在内存分配失败时抛出 std::bad_alloc 异常。
```


# 浅拷贝与深拷贝的区别
```c++
浅拷贝（Shallow Copy）
浅拷贝是指在复制对象时，只复制对象的基本数据成员，而不复制指针成员所指向的内存。
这意味着两个对象中的指针成员将指向同一块内存。

如果原对象或复制对象修改了指针成员所指向的内存，会影响另一个对象。
可能导致内存泄漏或悬挂指针（dangling pointer）问题。


深拷贝（Deep Copy）
深拷贝是指在复制对象时，不仅复制对象的基本数据成员，还复制指针成员所指向的内存。
这意味着两个对象中的指针成员将指向不同的内存，互不影响。

```

# 虚继承和虚函数
```c++
虚继承（Virtual Inheritance）
虚继承主要用于解决多重继承中的菱形继承问题（Diamond Problem）。
当一个类通过多条路径继承同一个基类时，会导致基类的多个实例，从而引发资源浪费和二义性问题。
虚继承通过共享基类的一个实例来解决这个问题。

虚函数（Virtual Function）
虚函数用于实现多态（Polymorphism）。
通过在基类中声明虚函数，派生类可以重写这些函数，
从而在运行时根据对象的实际类型调用正确的函数。
```